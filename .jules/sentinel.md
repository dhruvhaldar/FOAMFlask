## 2024-05-23 - Path Traversal in Mesh Visualizer
**Vulnerability:** The endpoints `/api/load_mesh`, `/api/mesh_screenshot`, and `/api/mesh_interactive` accepted a `file_path` parameter from the user and passed it directly to `pyvista.read` or `mesh_visualizer.load_mesh` without validation. This allowed users to potentially read arbitrary files on the server (if they were valid mesh formats or if `pyvista` supported them) or cause denial of service by loading non-mesh files.
**Learning:** Even if a library like `pyvista` seems specialized for 3D data, it performs file I/O and thus requires strict path validation when dealing with user-supplied paths. The assumption that "only mesh files will load" is insufficient protection against path traversal.
**Prevention:** Always validate user-supplied file paths using a strict "allow-list" approach or by ensuring the path resolves to a subdirectory of a trusted root (using `pathlib.Path.is_relative_to` after `resolve()`) before passing it to any file opening function. I applied `validate_safe_path(CASE_ROOT, file_path)` to all affected endpoints.

## 2024-05-23 - Path Traversal in Case Creation
**Vulnerability:** The `/api/case/create` endpoint accepted a `caseName` parameter and used it to construct a path `Path(CASE_ROOT) / case_name` which was then passed to `CaseManager.create_case_structure`. The `CaseManager` resolved the path but did not check if it was within `CASE_ROOT`. This allowed users to create directories (and potentially files like `controlDict`) anywhere on the filesystem where the process had write permissions by using `../` in the case name.
**Learning:** Checking for "safe" paths must happen at the boundary (API endpoint) before business logic is invoked. Even "creation" logic can be a vector for traversal if it involves creating directories at user-controlled paths.
**Prevention:** Applied `validate_safe_path(CASE_ROOT, case_name)` in `api_create_case` before passing the path to the manager. This ensures the target path is strictly within the allowed `CASE_ROOT`.

## 2024-05-24 - Path Traversal in Geometry and Meshing Endpoints
**Vulnerability:** Several API endpoints (`/api/geometry/list`, `/api/geometry/upload`, `/api/geometry/delete`, `/api/meshing/blockMesh/config`, `/api/meshing/snappyHexMesh/config`, `/api/meshing/run`) accepted a `caseName` parameter and constructed file paths using `Path(CASE_ROOT) / case_name` without validation. This allowed path traversal (e.g., `caseName=../secret`) to access or modify files outside the intended case root directory.
**Learning:** Relying on `request.form.get()` or `request.get_json()` input directly for path construction is dangerous. Even if `CASE_ROOT` is safe, appending a user-controlled `../` segment bypasses the root restriction. This pattern was repeated across multiple endpoints, indicating a need for a centralized validation mechanism to be applied consistently.
**Prevention:** Applied `validate_safe_path(CASE_ROOT, case_name)` to all affected endpoints in `app.py`. This function resolves the path and explicitly checks if it `is_relative_to(CASE_ROOT)`. Future endpoints handling file paths must use this validation utility before any filesystem operations.

## 2026-01-11 - Brace Expansion in Command Validation
**Vulnerability:** The `is_safe_command` blacklist validation in `app.py` blocked many shell metacharacters but missed brace expansion (`{` and `}`). While not directly leading to Remote Code Execution (RCE) in this specific app due to other structural constraints, brace expansion can be used to generate arguments or create multiple files (e.g., `touch {a,b}`), which might bypass certain logic or cause unexpected behavior in shell scripts constructed via string concatenation.
**Learning:** Blacklisting is inherently fragile because shell syntax is rich and constantly evolving. Brace expansion is a less common but valid vector for manipulating command arguments.
**Prevention:** Added `{` and `}` to the `dangerous_chars` list in `is_safe_command`. Ideally, applications should avoid constructing shell commands from user input entirely, but when necessary, strict whitelisting (which was partially present in `run_case` logic but not `is_safe_command` itself) is superior to blacklisting.

## 2026-02-12 - Insecure Default Network Binding
**Vulnerability:** The Flask application was configured to listen on `0.0.0.0` by default if the `FLASK_HOST` environment variable was not set. This exposed the application to all network interfaces, potentially allowing unauthorized access from other devices on the same network, which is risky for a tool that executes Docker commands.
**Learning:** Default configurations should always favor security ("secure by default"). Binding to `0.0.0.0` is convenient for deployment but dangerous for local development tools unless explicitly intended.
**Prevention:** Changed the default host in `app.py` to `127.0.0.1` (localhost). This ensures the application is only accessible from the local machine by default, reducing the attack surface. Users can still override this via the `FLASK_HOST` environment variable if needed.

## 2026-03-01 - Secure Shell Command Construction in Meshing Runner
**Vulnerability:** The `MeshingRunner` constructed shell commands by interpolating the `command` variable directly into a `bash -c '...'` string. While `app.py` restricted the input to a whitelist, the library code itself was vulnerable to shell injection if reused with unsafe input (e.g., `blockMesh; echo INJECTED`).
**Learning:** String interpolation for shell commands is inherently dangerous, even with surrounding quotes, as injection can escape the quotes or occur if the variable itself contains control characters.
**Prevention:** I modified `MeshingRunner` to use the `list` format for `docker_client.containers.run`, passing arguments safely to `bash` via positional parameters (`source "$1" && cd "$2" && $3`). This ensures that the command is treated as a single argument by the shell and not parsed for control operators, preventing injection while still allowing path handling.
